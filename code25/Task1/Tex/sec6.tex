\newpage
\section*{思考题}

\begin{enumerate}
  \item \textbf{Cortex-M0 执行完一条非跳转指令之后，PC 寄存器的值怎样变化？}

  Cortex-M0 使用顺序执行和三级流水线结构。对一条普通的非跳转 Thumb 指令来说，硬件会在执行结束后自动把程序计数器 $PC$ 增加一个指令长度，使其指向“下一条指令”的地址：16 位指令时 $PC$ 增加 2 字节，32 位指令时增加 4 字节。因此，从程序员角度看，如果按地址顺序写代码，执行完一条非跳转指令后，$PC$ 会顺序指向下一条指令的首地址。

  \item \textbf{为什么 Cortex-M0 使用的寄存器都是低寄存器（即 R0--R7）？}

  Cortex-M0 只实现了 Thumb-1 子集，大多数数据处理指令采用 16 位定长编码，指令中用于指出寄存器的字段只有 3 位，因此一次最多只能直接编码 8 个寄存器号。为了提高代码密度、简化硬件解码逻辑，Thumb-1 规定普通算术、逻辑指令优先使用低寄存器 $R0\sim R7$，而高寄存器（$R8\sim R12$、$SP$、$LR$、$PC$）通常通过专用指令或特定用途访问。这样既保持了较小的内核面积和功耗，又能兼顾较好的代码密度，非常适合 Cortex-M0 这类低功耗嵌入式应用。 

  \item \textbf{结合 Keil 的调试过程，简要说明 Cortex-M0 的启动过程？}

  在上电或复位后，Cortex-M0 首先从地址 0x00000000 处读取初始栈顶值装入 $SP$，再从地址 0x00000004 处读取复位向量，即 \verb|Reset_Handler| 的入口地址装入 $PC$，开始执行启动代码。在 Keil 调试时可以看到，程序一开始就跳入启动文件中的 \verb|Reset_Handler|：这里通常完成堆栈初始化、拷贝初始化数据段、清零 BSS 段，以及（必要时）调用系统初始化函数 \verb|SystemInit| 等。随后启动代码再跳转到 C 运行库入口或用户的 \verb|main| 函数（本实验中是直接 \verb|LDR r0, =main; BX r0|），此后程序进入用户编写的 C/汇编主程序逻辑。通过单步调试可以清楚地看到 $PC$ 从向量表指向 \verb|Reset_Handler|，再从 \verb|Reset_Handler| 跳转到 \verb|main| 的完整启动过程。
\end{enumerate}
